diff -ruNE openjdk/hotspot/make/linux/makefiles/rules.make openjdk/hotspot/make/linux/makefiles/rules.make
--- openjdk/hotspot/make/linux/makefiles/rules.make	2009-02-16 18:42:06.000000000 +0000
+++ openjdk/hotspot/make/linux/makefiles/rules.make	2009-02-17 10:21:19.000000000 +0000
@@ -148,6 +148,11 @@
 	$(QUIETLY) $(REMOVE_TARGET)
 	$(QUIETLY) $(AS.S) -o $@ $< $(COMPILE_DONE)
 
+%.o: %.S
+	@echo Assembling $<
+	$(QUIETLY) $(REMOVE_TARGET)
+	$(COMPILE.CC) -o $@ $< $(COMPILE_DONE)
+
 %.s: %.cpp
 	@echo Generating assembly for $<
 	$(QUIETLY) $(GENASM.CC) -o $@ $<
diff -ruNE openjdk/hotspot/src/share/vm/includeDB_core openjdk/hotspot/src/share/vm/includeDB_core
--- openjdk/hotspot/src/share/vm/includeDB_core	2008-11-22 00:11:18.000000000 +0000
+++ openjdk/hotspot/src/share/vm/includeDB_core	2009-02-17 10:33:47.000000000 +0000
@@ -393,6 +393,8 @@
 bytecodeInterpreter.cpp                 threadCritical.hpp
 bytecodeInterpreter.cpp                 vmSymbols.hpp
 
+bytecodeInterpreterOpt.cpp		bytecodeInterpreter.hpp
+
 bytecodeInterpreter_<arch>.cpp          assembler.hpp
 bytecodeInterpreter_<arch>.cpp          bytecodeInterpreter.hpp
 bytecodeInterpreter_<arch>.cpp          bytecodeInterpreter.inline.hpp
diff -ruNE openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp
--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	2009-02-16 18:42:27.000000000 +0000
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	2009-02-17 10:23:06.000000000 +0000
@@ -46,6 +46,21 @@
 #endif
 #endif
 
+/*
+ * If HOTSPOT_OPT set turn USELABELS off. This is because each time round the loop
+ * it needs to test the execute_opt[] array to check whether optimized execution
+ * exists for the current bytecode and if so xfer control to run_opt.
+ * It may be possible to do this as part of the CONTINUE macro however it is
+ * probably not worth it as the outer loop is not performance critical.
+ */
+#ifdef HOTSPOT_OPT
+#undef USELABELS
+#endif
+
+#ifdef VM_JVMTI
+#undef HOTSPOT_OPT
+#endif
+
 #undef CASE
 #ifdef USELABELS
 #define CASE(opcode) opc ## opcode
@@ -856,6 +871,19 @@
       assert(topOfStack >= istate->stack_limit(), "Stack overrun");
       assert(topOfStack < istate->stack_base(), "Stack underrun");
 
+#ifdef HOTSPOT_OPT
+  extern const char execute_opt[256];
+  if (!TaggedStackInterpreter && !UseCompiler) {
+    if (execute_opt[opcode]) {
+      DECACHE_STATE();
+      run_opt(istate);
+      CACHE_TOS();
+      CACHE_PC();
+      opcode = *pc;
+    }
+  }
+#endif
+
 #ifdef USELABELS
       DISPATCH(opcode);
 #else
diff -ruNE openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.hpp openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.hpp
--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.hpp	2009-02-16 18:42:28.000000000 +0000
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.hpp	2009-02-17 10:24:22.000000000 +0000
@@ -496,6 +496,7 @@
 
 // The Interpreter used when
 static void run(interpreterState istate);
+static int run_opt(interpreterState istate);
 // The interpreter used if JVMTI needs interpreter events
 static void runWithChecks(interpreterState istate);
 static void End_Of_Interpreter(void);
diff -ruNE openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreterOpt.cpp openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreterOpt.cpp
--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreterOpt.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreterOpt.cpp	2009-02-17 10:25:54.000000000 +0000
@@ -0,0 +1,1282 @@
+/*
+ * Copyright 2002-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+
+// no precompiled headers
+#include "incls/_bytecodeInterpreter.cpp.incl"
+
+#if defined(CC_INTERP) && defined(HOTSPOT_OPT) && !defined(HOTSPOT_ASM)
+
+#ifdef VM_JVMTI
+#error VM_JVMTI must not be defined in bytecodeInterpreterOpt.cpp
+#endif
+
+#define CASE(opcode) opc ## opcode
+#define DEFAULT opc_default
+
+#define FINISH() {					\
+		DECACHE_STATE();			\
+		return 0;				\
+	}
+
+/*
+  Interpreter safepoint: it is expected that the interpreter will have no live
+  handles of its own creation live at an interpreter safepoint. Therefore we
+  run a HandleMarkCleaner and trash all handles allocated in the call chain
+  since the JavaCalls::call_helper invocation that initiated the chain.
+  There really shouldn't be any handles remaining to trash but this is cheap
+  in relation to a safepoint.
+*/
+#define SAFEPOINT					\
+    if ( SafepointSynchronize::is_synchronizing()) {	\
+	DECACHE_TOS();					\
+	DECACHE_PC();					\
+	FINISH();					\
+    }
+
+/*
+ * CONTINUE - Macro for executing the next opcode.
+ */
+#undef CONTINUE
+// Have to do this dispatch this way in C++ because otherwise gcc complains about crossing an
+// initialization (which is is the initialization of the table pointer...)
+#define DISPATCH(opcode) goto *(void*)dispatch_table[opcode]
+#define CONTINUE {                              \
+        opcode = *pc;                           \
+        DISPATCH(opcode);                       \
+    }
+
+// JavaStack Implementation
+#define MORE_STACK(count)  \
+    (topOfStack -= (count))
+
+
+#define UPDATE_PC(opsize) {pc += opsize; }
+/*
+ * UPDATE_PC_AND_TOS - Macro for updating the pc and topOfStack.
+ */
+#undef UPDATE_PC_AND_TOS
+#define UPDATE_PC_AND_TOS(opsize, stack) \
+    {pc += opsize; MORE_STACK(stack); }
+
+/*
+ * UPDATE_PC_AND_TOS_AND_CONTINUE - Macro for updating the pc and topOfStack,
+ * and executing the next opcode. It's somewhat similar to the combination
+ * of UPDATE_PC_AND_TOS and CONTINUE, but with some minor optimizations.
+ */
+#undef UPDATE_PC_AND_TOS_AND_CONTINUE
+#define UPDATE_PC_AND_TOS_AND_CONTINUE(opsize, stack) {         \
+        pc += opsize; opcode = *pc; MORE_STACK(stack);          \
+        DISPATCH(opcode);                                       \
+    }
+
+#define UPDATE_PC_AND_CONTINUE(opsize) {                        \
+        pc += opsize; opcode = *pc;                             \
+        DISPATCH(opcode);                                       \
+    }
+
+#define METHOD istate->method()
+#define INVOCATION_COUNT METHOD->invocation_counter()
+
+
+#define INCR_INVOCATION_COUNT INVOCATION_COUNT->increment()
+/*
+ * For those opcodes that need to have a GC point on a backwards branch
+ */
+#define DO_BACKEDGE_CHECKS(skip) {	\
+	if ((skip) < 0) {		\
+		SAFEPOINT;		\
+		INCR_INVOCATION_COUNT;	\
+	}				\
+}
+
+/*
+ * For those opcodes that need to have a GC point on a backwards branch
+ */
+
+/*
+ * Macros for caching and flushing the interpreter state. Some local
+ * variables need to be flushed out to the frame before we do certain
+ * things (like pushing frames or becomming gc safe) and some need to
+ * be recached later (like after popping a frame). We could use one
+ * macro to cache or decache everything, but this would be less then
+ * optimal because we don't always need to cache or decache everything
+ * because some things we know are already cached or decached.
+ */
+#undef DECACHE_TOS
+#undef CACHE_TOS
+#undef CACHE_PREV_TOS
+#define DECACHE_TOS()    istate->set_stack(topOfStack);
+
+#define CACHE_TOS()      topOfStack = (intptr_t *)istate->stack();
+
+#undef DECACHE_PC
+#undef CACHE_PC
+#define DECACHE_PC()    istate->set_bcp(pc);
+#define CACHE_PC()      pc = istate->bcp();
+#define CACHE_CP()      cp = istate->constants();
+#define CACHE_LOCALS()  locals = istate->locals();
+#undef CACHE_FRAME
+#define CACHE_FRAME()
+
+/*
+ * CHECK_NULL - Macro for throwing a NullPointerException if the object
+ * passed is a null ref.
+ * On some architectures/platforms it should be possible to do this implicitly
+ */
+#undef CHECK_NULL
+#define CHECK_NULL(obj_)                                                 \
+    if ((obj_) == NULL) {                                                \
+        goto finish;  							 \
+    }
+
+#define VMdoubleConstZero() 0.0
+#define VMdoubleConstOne() 1.0
+#define VMlongConstZero() (max_jlong-max_jlong)
+#define VMlongConstOne() ((max_jlong-max_jlong)+1)
+
+/*
+ * Alignment
+ */
+#define VMalignWordUp(val)          (((uintptr_t)(val) + 3) & ~3)
+
+// Decache the interpreter state that interpreter modifies directly (i.e. GC is indirect mod)
+#define DECACHE_STATE() DECACHE_PC(); DECACHE_TOS();
+
+// Reload interpreter state after calling the VM or a possible GC
+#define CACHE_STATE()   \
+        CACHE_TOS();    \
+        CACHE_PC();     \
+        CACHE_CP();     \
+        CACHE_LOCALS();
+
+extern const char execute_opt[256] = {
+	1,1,1,1,	// 0x00
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x10
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x20
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x30
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x40
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,0,	// 0x50
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x60
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x70
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x80
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0x90
+	1,1,1,1,
+	1,1,1,1,
+	1,1,1,1,
+
+	1,1,1,1,	// 0xA0
+	1,1,1,1,
+	1,1,1,1,
+	0,0,0,0,
+
+	0,0,1,0,	// 0xB0
+	1,0,0,0,
+	0,0,0,0,
+	0,0,1,0,
+
+	0,0,0,0,	// 0xC0
+	0,0,1,1,
+	0,0,0,0,
+	0,0,0,0,
+
+	0,0,0,0,	// 0xD0
+	0,0,0,0,
+	0,0,0,0,
+	0,0,0,0,
+
+	0,0,0,0,	// 0xE0
+	0,0,0,0,
+	0,0,0,0,
+	0,0,0,0,
+
+	0,0,0,0,	// 0xF0
+	0,0,0,0,
+	0,0,0,0,
+	0,0,0,0
+};
+
+/*
+ * BytecodeInterpreter::run_opt(interpreterState istate)
+ *
+ */
+int BytecodeInterpreter::run_opt(interpreterState istate) {
+
+  static int _compiling;  // (UseCompiler || CountCompiledCalls)
+
+  register intptr_t*        topOfStack = (intptr_t *)istate->stack(); /* access with STACK macros */
+  register address          pc = istate->bcp();
+  register jubyte opcode;
+  register intptr_t*        locals = istate->locals();
+  register constantPoolCacheOop  cp = istate->constants(); // method()->constants()->cache()
+
+  const static void* const opclabels_data[256] = {
+/* 0x00 */ &&opc_nop,     &&opc_aconst_null,&&opc_iconst_m1,&&opc_iconst_0,
+/* 0x04 */ &&opc_iconst_1,&&opc_iconst_2,   &&opc_iconst_3, &&opc_iconst_4,
+/* 0x08 */ &&opc_iconst_5,&&opc_lconst_0,   &&opc_lconst_1, &&opc_fconst_0,
+/* 0x0C */ &&opc_fconst_1,&&opc_fconst_2,   &&opc_dconst_0, &&opc_dconst_1,
+
+/* 0x10 */ &&opc_bipush, &&opc_sipush, &&opc_ldc,    &&opc_ldc_w,
+/* 0x14 */ &&opc_ldc2_w, &&opc_iload,  &&opc_lload,  &&opc_fload,
+/* 0x18 */ &&opc_dload,  &&opc_aload,  &&opc_iload_0,&&opc_iload_1,
+/* 0x1C */ &&opc_iload_2,&&opc_iload_3,&&opc_lload_0,&&opc_lload_1,
+
+/* 0x20 */ &&opc_lload_2,&&opc_lload_3,&&opc_fload_0,&&opc_fload_1,
+/* 0x24 */ &&opc_fload_2,&&opc_fload_3,&&opc_dload_0,&&opc_dload_1,
+/* 0x28 */ &&opc_dload_2,&&opc_dload_3,&&opc_aload_0,&&opc_aload_1,
+/* 0x2C */ &&opc_aload_2,&&opc_aload_3,&&opc_iaload, &&opc_laload,
+
+/* 0x30 */ &&opc_faload,  &&opc_daload,  &&opc_aaload,  &&opc_baload,
+/* 0x34 */ &&opc_caload,  &&opc_saload,  &&opc_istore,  &&opc_lstore,
+/* 0x38 */ &&opc_fstore,  &&opc_dstore,  &&opc_astore,  &&opc_istore_0,
+/* 0x3C */ &&opc_istore_1,&&opc_istore_2,&&opc_istore_3,&&opc_lstore_0,
+
+/* 0x40 */ &&opc_lstore_1,&&opc_lstore_2,&&opc_lstore_3,&&opc_fstore_0,
+/* 0x44 */ &&opc_fstore_1,&&opc_fstore_2,&&opc_fstore_3,&&opc_dstore_0,
+/* 0x48 */ &&opc_dstore_1,&&opc_dstore_2,&&opc_dstore_3,&&opc_astore_0,
+/* 0x4C */ &&opc_astore_1,&&opc_astore_2,&&opc_astore_3,&&opc_iastore,
+
+/* 0x50 */ &&opc_lastore,&&opc_fastore,&&opc_dastore,&&opc_aastore,
+/* 0x54 */ &&opc_bastore,&&opc_castore,&&opc_sastore,&&opc_pop,
+/* 0x58 */ &&opc_pop2,   &&opc_dup,    &&opc_dup_x1, &&opc_dup_x2,
+/* 0x5C */ &&opc_dup2,   &&opc_dup2_x1,&&opc_dup2_x2,&&opc_swap,
+
+/* 0x60 */ &&opc_iadd,&&opc_ladd,&&opc_fadd,&&opc_dadd,
+/* 0x64 */ &&opc_isub,&&opc_lsub,&&opc_fsub,&&opc_dsub,
+/* 0x68 */ &&opc_imul,&&opc_lmul,&&opc_fmul,&&opc_dmul,
+/* 0x6C */ &&opc_idiv,&&opc_ldiv,&&opc_fdiv,&&opc_ddiv,
+
+/* 0x70 */ &&opc_irem, &&opc_lrem, &&opc_frem,&&opc_drem,
+/* 0x74 */ &&opc_ineg, &&opc_lneg, &&opc_fneg,&&opc_dneg,
+/* 0x78 */ &&opc_ishl, &&opc_lshl, &&opc_ishr,&&opc_lshr,
+/* 0x7C */ &&opc_iushr,&&opc_lushr,&&opc_iand,&&opc_land,
+
+/* 0x80 */ &&opc_ior, &&opc_lor,&&opc_ixor,&&opc_lxor,
+/* 0x84 */ &&opc_iinc,&&opc_i2l,&&opc_i2f, &&opc_i2d,
+/* 0x88 */ &&opc_l2i, &&opc_l2f,&&opc_l2d, &&opc_f2i,
+/* 0x8C */ &&opc_f2l, &&opc_f2d,&&opc_d2i, &&opc_d2l,
+
+/* 0x90 */ &&opc_d2f,  &&opc_i2b,  &&opc_i2c,  &&opc_i2s,
+/* 0x94 */ &&opc_lcmp, &&opc_fcmpl,&&opc_fcmpg,&&opc_dcmpl,
+/* 0x98 */ &&opc_dcmpg,&&opc_ifeq, &&opc_ifne, &&opc_iflt,
+/* 0x9C */ &&opc_ifge, &&opc_ifgt, &&opc_ifle, &&opc_if_icmpeq,
+
+/* 0xA0 */ &&opc_if_icmpne,&&opc_if_icmplt,&&opc_if_icmpge,  &&opc_if_icmpgt,
+/* 0xA4 */ &&opc_if_icmple,&&opc_if_acmpeq,&&opc_if_acmpne,  &&opc_goto,
+/* 0xA8 */ &&opc_jsr,      &&opc_ret,      &&opc_tableswitch,&&opc_lookupswitch,
+/* 0xAC */ &&opc_ireturn,  &&opc_lreturn,  &&opc_freturn,    &&opc_dreturn,
+
+/* 0xB0 */ &&opc_areturn,     &&opc_return,         &&opc_getstatic,    &&opc_putstatic,
+/* 0xB4 */ &&opc_getfield,    &&opc_putfield,       &&opc_invokevirtual,&&opc_invokespecial,
+/* 0xB8 */ &&opc_invokestatic,&&opc_invokeinterface,NULL,               &&opc_new,
+/* 0xBC */ &&opc_newarray,    &&opc_anewarray,      &&opc_arraylength,  &&opc_athrow,
+
+/* 0xC0 */ &&opc_checkcast,   &&opc_instanceof,     &&opc_monitorenter, &&opc_monitorexit,
+/* 0xC4 */ &&opc_wide,        &&opc_multianewarray, &&opc_ifnull,       &&opc_ifnonnull,
+/* 0xC8 */ &&opc_goto_w,      &&opc_jsr_w,          &&opc_breakpoint,   &&opc_default,
+/* 0xCC */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+
+/* 0xD0 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xD4 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xD8 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xDC */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+
+/* 0xE0 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xE4 */ &&opc_default,     &&opc_return_register_finalizer,        &&opc_default,      &&opc_default,
+/* 0xE8 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xEC */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+
+/* 0xF0 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xF4 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xF8 */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default,
+/* 0xFC */ &&opc_default,     &&opc_default,        &&opc_default,      &&opc_default
+  };
+  register uintptr_t *dispatch_table = (uintptr_t*)&opclabels_data[0];
+
+  opcode = *pc;  /* prefetch first opcode */
+
+  {
+
+  opcode_switch:
+
+      DISPATCH(opcode);
+      {
+
+	CASE(_putfield):
+	CASE(_putstatic):
+	CASE(_aastore):
+	CASE(_ireturn):
+	CASE(_lreturn):
+	CASE(_freturn):
+	CASE(_dreturn):
+	CASE(_areturn):
+	CASE(_return):
+	CASE(_invokevirtual):
+	CASE(_invokespecial):
+	CASE(_invokestatic):
+	CASE(_invokeinterface):
+	CASE(_new):
+	CASE(_newarray):
+	CASE(_anewarray):
+	CASE(_athrow):
+	CASE(_checkcast):
+	CASE(_instanceof):
+	CASE(_monitorenter):
+	CASE(_monitorexit):
+	CASE(_wide):
+	CASE(_multianewarray):
+	CASE(_goto_w):
+	CASE(_jsr_w):
+	CASE(_breakpoint):
+	CASE(_return_register_finalizer):
+	DEFAULT:
+		goto finish;
+
+      CASE(_nop):
+          UPDATE_PC_AND_CONTINUE(1);
+
+          /* Push miscellaneous constants onto the stack. */
+
+      CASE(_aconst_null):
+          SET_STACK_OBJECT(NULL, 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+
+#undef  OPC_CONST_n
+#define OPC_CONST_n(opcode, const_type, value)                          \
+      CASE(opcode):                                                     \
+          SET_STACK_ ## const_type(value, 0);                           \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+
+          OPC_CONST_n(_iconst_m1,   INT,       -1);
+          OPC_CONST_n(_iconst_0,    INT,        0);
+          OPC_CONST_n(_iconst_1,    INT,        1);
+          OPC_CONST_n(_iconst_2,    INT,        2);
+          OPC_CONST_n(_iconst_3,    INT,        3);
+          OPC_CONST_n(_iconst_4,    INT,        4);
+          OPC_CONST_n(_iconst_5,    INT,        5);
+          OPC_CONST_n(_fconst_0,    FLOAT,      0.0);
+          OPC_CONST_n(_fconst_1,    FLOAT,      1.0);
+          OPC_CONST_n(_fconst_2,    FLOAT,      2.0);
+
+#undef  OPC_CONST2_n
+#define OPC_CONST2_n(opcname, value, key, kind)                         \
+      CASE(_##opcname):                                                 \
+      {                                                                 \
+          SET_STACK_ ## kind(VM##key##Const##value(), 1);               \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);                         \
+      }
+         OPC_CONST2_n(dconst_0, Zero, double, DOUBLE);
+         OPC_CONST2_n(dconst_1, One,  double, DOUBLE);
+         OPC_CONST2_n(lconst_0, Zero, long, LONG);
+         OPC_CONST2_n(lconst_1, One,  long, LONG);
+
+         /* Load constant from constant pool: */
+
+          /* Push a 1-byte signed integer value onto the stack. */
+      CASE(_bipush):
+          SET_STACK_INT((jbyte)(pc[1]), 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);
+
+          /* Push a 2-byte signed integer constant onto the stack. */
+      CASE(_sipush):
+          SET_STACK_INT((int16_t)Bytes::get_Java_u2(pc + 1), 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1);
+
+          /* load from local variable */
+
+      CASE(_aload):
+          SET_STACK_OBJECT(LOCALS_OBJECT(pc[1]), 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);
+
+      CASE(_iload):
+      CASE(_fload):
+          SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);
+
+      CASE(_lload):
+          SET_STACK_LONG_FROM_ADDR(LOCALS_LONG_AT(pc[1]), 1);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, 2);
+
+      CASE(_dload):
+          SET_STACK_DOUBLE_FROM_ADDR(LOCALS_DOUBLE_AT(pc[1]), 1);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, 2);
+
+#undef  OPC_LOAD_n
+#define OPC_LOAD_n(num)                                                 \
+      CASE(_aload_##num):                                               \
+          SET_STACK_OBJECT(LOCALS_OBJECT(num), 0);                      \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \
+                                                                        \
+      CASE(_iload_##num):                                               \
+      CASE(_fload_##num):                                               \
+          SET_STACK_SLOT(LOCALS_SLOT(num), 0);                          \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \
+                                                                        \
+      CASE(_lload_##num):                                               \
+          SET_STACK_LONG_FROM_ADDR(LOCALS_LONG_AT(num), 1);             \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);                         \
+      CASE(_dload_##num):                                               \
+          SET_STACK_DOUBLE_FROM_ADDR(LOCALS_DOUBLE_AT(num), 1);         \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+
+          OPC_LOAD_n(0);
+          OPC_LOAD_n(1);
+          OPC_LOAD_n(2);
+          OPC_LOAD_n(3);
+
+          /* store to a local variable */
+
+      CASE(_astore):
+          astore(topOfStack, -1, locals, pc[1]);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, -1);
+
+      CASE(_istore):
+      CASE(_fstore):
+          SET_LOCALS_SLOT(STACK_SLOT(-1), pc[1]);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, -1);
+
+      CASE(_lstore):
+          SET_LOCALS_LONG(STACK_LONG(-1), pc[1]);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, -2);
+
+      CASE(_dstore):
+          SET_LOCALS_DOUBLE(STACK_DOUBLE(-1), pc[1]);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, -2);
+
+#undef  OPC_STORE_n
+#define OPC_STORE_n(num)                                                \
+      CASE(_astore_##num):                                              \
+          astore(topOfStack, -1, locals, num);                          \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);                        \
+      CASE(_istore_##num):                                              \
+      CASE(_fstore_##num):                                              \
+          SET_LOCALS_SLOT(STACK_SLOT(-1), num);                         \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
+
+          OPC_STORE_n(0);
+          OPC_STORE_n(1);
+          OPC_STORE_n(2);
+          OPC_STORE_n(3);
+
+#undef  OPC_DSTORE_n
+#define OPC_DSTORE_n(num)                                               \
+      CASE(_dstore_##num):                                              \
+          SET_LOCALS_DOUBLE(STACK_DOUBLE(-1), num);                     \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -2);                        \
+      CASE(_lstore_##num):                                              \
+          SET_LOCALS_LONG(STACK_LONG(-1), num);                         \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -2);
+
+          OPC_DSTORE_n(0);
+          OPC_DSTORE_n(1);
+          OPC_DSTORE_n(2);
+          OPC_DSTORE_n(3);
+
+          /* stack pop, dup, and insert opcodes */
+
+
+      CASE(_pop):                /* Discard the top item on the stack */
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
+
+
+      CASE(_pop2):               /* Discard the top 2 items on the stack */
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -2);
+
+
+      CASE(_dup):               /* Duplicate the top item on the stack */
+          dup(topOfStack);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+
+      CASE(_dup2):              /* Duplicate the top 2 items on the stack */
+          dup2(topOfStack);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+
+      CASE(_dup_x1):    /* insert top word two down */
+          dup_x1(topOfStack);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+
+      CASE(_dup_x2):    /* insert top word three down  */
+          dup_x2(topOfStack);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+
+      CASE(_dup2_x1):   /* insert top 2 slots three down */
+          dup2_x1(topOfStack);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+
+      CASE(_dup2_x2):   /* insert top 2 slots four down */
+          dup2_x2(topOfStack);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+
+      CASE(_swap): {        /* swap top two elements on the stack */
+          swap(topOfStack);
+          UPDATE_PC_AND_CONTINUE(1);
+      }
+
+          /* Perform various binary integer operations */
+
+#undef  OPC_INT_BINARY
+#define OPC_INT_BINARY(opcname, opname, test)                           \
+      CASE(_i##opcname):                                                \
+          if (test && (STACK_INT(-1) == 0)) {                           \
+		goto finish;						\
+          }                                                             \
+          SET_STACK_INT(VMint##opname(STACK_INT(-2),                    \
+                                      STACK_INT(-1)),                   \
+                                      -2);                              \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);                        \
+      CASE(_l##opcname):                                                \
+      {                                                                 \
+          if (test) {                                                   \
+            jlong l1 = STACK_LONG(-1);                                  \
+            if (VMlongEqz(l1)) {                                        \
+		goto finish;						\
+            }                                                           \
+          }                                                             \
+          /* First long at (-1,-2) next long at (-3,-4) */              \
+          SET_STACK_LONG(VMlong##opname(STACK_LONG(-3),                 \
+                                        STACK_LONG(-1)),                \
+                                        -3);                            \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -2);                        \
+      }
+
+      OPC_INT_BINARY(add, Add, 0);
+      OPC_INT_BINARY(sub, Sub, 0);
+      OPC_INT_BINARY(mul, Mul, 0);
+      OPC_INT_BINARY(and, And, 0);
+      OPC_INT_BINARY(or,  Or,  0);
+      OPC_INT_BINARY(xor, Xor, 0);
+      OPC_INT_BINARY(div, Div, 1);
+      OPC_INT_BINARY(rem, Rem, 1);
+
+
+      /* Perform various binary floating number operations */
+      /* On some machine/platforms/compilers div zero check can be implicit */
+
+#undef  OPC_FLOAT_BINARY
+#define OPC_FLOAT_BINARY(opcname, opname)                                  \
+      CASE(_d##opcname): {                                                 \
+          SET_STACK_DOUBLE(VMdouble##opname(STACK_DOUBLE(-3),              \
+                                            STACK_DOUBLE(-1)),             \
+                                            -3);                           \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -2);                           \
+      }                                                                    \
+      CASE(_f##opcname):                                                   \
+          SET_STACK_FLOAT(VMfloat##opname(STACK_FLOAT(-2),                 \
+                                          STACK_FLOAT(-1)),                \
+                                          -2);                             \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
+
+
+     OPC_FLOAT_BINARY(add, Add);
+     OPC_FLOAT_BINARY(sub, Sub);
+     OPC_FLOAT_BINARY(mul, Mul);
+     OPC_FLOAT_BINARY(div, Div);
+     OPC_FLOAT_BINARY(rem, Rem);
+
+      /* Shift operations
+       * Shift left int and long: ishl, lshl
+       * Logical shift right int and long w/zero extension: iushr, lushr
+       * Arithmetic shift right int and long w/sign extension: ishr, lshr
+       */
+
+#undef  OPC_SHIFT_BINARY
+#define OPC_SHIFT_BINARY(opcname, opname)                               \
+      CASE(_i##opcname):                                                \
+         SET_STACK_INT(VMint##opname(STACK_INT(-2),                     \
+                                     STACK_INT(-1)),                    \
+                                     -2);                               \
+         UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);                         \
+      CASE(_l##opcname):                                                \
+      {                                                                 \
+         SET_STACK_LONG(VMlong##opname(STACK_LONG(-2),                  \
+                                       STACK_INT(-1)),                  \
+                                       -2);                             \
+         UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);                         \
+      }
+
+      OPC_SHIFT_BINARY(shl, Shl);
+      OPC_SHIFT_BINARY(shr, Shr);
+      OPC_SHIFT_BINARY(ushr, Ushr);
+
+     /* Increment local variable by constant */
+      CASE(_iinc):
+      {
+          // locals[pc[1]].j.i += (jbyte)(pc[2]);
+          SET_LOCALS_INT(LOCALS_INT(pc[1]) + (jbyte)(pc[2]), pc[1]);
+          UPDATE_PC_AND_CONTINUE(3);
+      }
+
+     /* negate the value on the top of the stack */
+
+      CASE(_ineg):
+         SET_STACK_INT(VMintNeg(STACK_INT(-1)), -1);
+         UPDATE_PC_AND_CONTINUE(1);
+
+      CASE(_fneg):
+         SET_STACK_FLOAT(VMfloatNeg(STACK_FLOAT(-1)), -1);
+         UPDATE_PC_AND_CONTINUE(1);
+
+      CASE(_lneg):
+      {
+         SET_STACK_LONG(VMlongNeg(STACK_LONG(-1)), -1);
+         UPDATE_PC_AND_CONTINUE(1);
+      }
+
+      CASE(_dneg):
+      {
+         SET_STACK_DOUBLE(VMdoubleNeg(STACK_DOUBLE(-1)), -1);
+         UPDATE_PC_AND_CONTINUE(1);
+      }
+
+      /* Conversion operations */
+
+      CASE(_i2f):       /* convert top of stack int to float */
+         SET_STACK_FLOAT(VMint2Float(STACK_INT(-1)), -1);
+         UPDATE_PC_AND_CONTINUE(1);
+
+      CASE(_i2l):       /* convert top of stack int to long */
+      {
+          // this is ugly QQQ
+          jlong r = VMint2Long(STACK_INT(-1));
+          MORE_STACK(-1); // Pop
+          SET_STACK_LONG(r, 1);
+
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+      }
+
+      CASE(_i2d):       /* convert top of stack int to double */
+      {
+          // this is ugly QQQ (why cast to jlong?? )
+          jdouble r = (jlong)STACK_INT(-1);
+          MORE_STACK(-1); // Pop
+          SET_STACK_DOUBLE(r, 1);
+
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+      }
+
+      CASE(_l2i):       /* convert top of stack long to int */
+      {
+          jint r = VMlong2Int(STACK_LONG(-1));
+          MORE_STACK(-2); // Pop
+          SET_STACK_INT(r, 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+      }
+
+      CASE(_l2f):   /* convert top of stack long to float */
+      {
+          jlong r = STACK_LONG(-1);
+          MORE_STACK(-2); // Pop
+          SET_STACK_FLOAT(VMlong2Float(r), 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+      }
+
+      CASE(_l2d):       /* convert top of stack long to double */
+      {
+          jlong r = STACK_LONG(-1);
+          MORE_STACK(-2); // Pop
+          SET_STACK_DOUBLE(VMlong2Double(r), 1);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+      }
+
+      CASE(_f2i):  /* Convert top of stack float to int */
+          SET_STACK_INT(SharedRuntime::f2i(STACK_FLOAT(-1)), -1);
+          UPDATE_PC_AND_CONTINUE(1);
+
+      CASE(_f2l):  /* convert top of stack float to long */
+      {
+          jlong r = SharedRuntime::f2l(STACK_FLOAT(-1));
+          MORE_STACK(-1); // POP
+          SET_STACK_LONG(r, 1);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+      }
+
+      CASE(_f2d):  /* convert top of stack float to double */
+      {
+          jfloat f;
+          jdouble r;
+          f = STACK_FLOAT(-1);
+          r = (jdouble) f;
+          MORE_STACK(-1); // POP
+          SET_STACK_DOUBLE(r, 1);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+      }
+
+      CASE(_d2i): /* convert top of stack double to int */
+      {
+          jint r1 = SharedRuntime::d2i(STACK_DOUBLE(-1));
+          MORE_STACK(-2);
+          SET_STACK_INT(r1, 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+      }
+
+      CASE(_d2f): /* convert top of stack double to float */
+      {
+          jfloat r1 = VMdouble2Float(STACK_DOUBLE(-1));
+          MORE_STACK(-2);
+          SET_STACK_FLOAT(r1, 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+      }
+
+      CASE(_d2l): /* convert top of stack double to long */
+      {
+          jlong r1 = SharedRuntime::d2l(STACK_DOUBLE(-1));
+          MORE_STACK(-2);
+          SET_STACK_LONG(r1, 1);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
+      }
+
+      CASE(_i2b):
+          SET_STACK_INT(VMint2Byte(STACK_INT(-1)), -1);
+          UPDATE_PC_AND_CONTINUE(1);
+
+      CASE(_i2c):
+          SET_STACK_INT(VMint2Char(STACK_INT(-1)), -1);
+          UPDATE_PC_AND_CONTINUE(1);
+
+      CASE(_i2s):
+          SET_STACK_INT(VMint2Short(STACK_INT(-1)), -1);
+          UPDATE_PC_AND_CONTINUE(1);
+
+      /* comparison operators */
+
+
+#define COMPARISON_OP(name, comparison)                                      \
+      CASE(_if_icmp##name): {                                                \
+          int skip = (STACK_INT(-2) comparison STACK_INT(-1))                \
+                      ? (int16_t)Bytes::get_Java_u2(pc + 1) : 3;             \
+          DO_BACKEDGE_CHECKS(skip);	                                     \
+          UPDATE_PC_AND_TOS(skip, -2);                                       \
+          CONTINUE;                                                          \
+      }                                                                      \
+      CASE(_if##name): {                                                     \
+          int skip = (STACK_INT(-1) comparison 0)                            \
+                      ? (int16_t)Bytes::get_Java_u2(pc + 1) : 3;             \
+          DO_BACKEDGE_CHECKS(skip);                                          \
+          UPDATE_PC_AND_TOS(skip, -1);                                       \
+          CONTINUE;                                                          \
+      }
+
+#define COMPARISON_OP2(name, comparison)                                     \
+      COMPARISON_OP(name, comparison)                                        \
+      CASE(_if_acmp##name): {                                                \
+          int skip = (STACK_OBJECT(-2) comparison STACK_OBJECT(-1))          \
+                       ? (int16_t)Bytes::get_Java_u2(pc + 1) : 3;            \
+          DO_BACKEDGE_CHECKS(skip);                                          \
+          UPDATE_PC_AND_TOS(skip, -2);                                       \
+          CONTINUE;                                                          \
+      }
+
+#define NULL_COMPARISON_NOT_OP(name)                                         \
+      CASE(_if##name): {                                                     \
+          int skip = (!(STACK_OBJECT(-1) == NULL))                           \
+                      ? (int16_t)Bytes::get_Java_u2(pc + 1) : 3;             \
+          DO_BACKEDGE_CHECKS(skip);                                          \
+          UPDATE_PC_AND_TOS(skip, -1);                                       \
+          CONTINUE;                                                          \
+      }
+
+#define NULL_COMPARISON_OP(name)                                             \
+      CASE(_if##name): {                                                     \
+          int skip = ((STACK_OBJECT(-1) == NULL))                            \
+                      ? (int16_t)Bytes::get_Java_u2(pc + 1) : 3;             \
+          DO_BACKEDGE_CHECKS(skip);                                          \
+          UPDATE_PC_AND_TOS(skip, -1);                                       \
+          CONTINUE;                                                          \
+      }
+      COMPARISON_OP(lt, <);
+      COMPARISON_OP(gt, >);
+      COMPARISON_OP(le, <=);
+      COMPARISON_OP(ge, >=);
+      COMPARISON_OP2(eq, ==);  /* include ref comparison */
+      COMPARISON_OP2(ne, !=);  /* include ref comparison */
+      NULL_COMPARISON_OP(null);
+      NULL_COMPARISON_NOT_OP(nonnull);
+
+      /* Goto pc at specified offset in switch table. */
+
+      CASE(_tableswitch): {
+          jint* lpc  = (jint*)VMalignWordUp(pc+1);
+          int32_t  key  = STACK_INT(-1);
+          int32_t  low  = Bytes::get_Java_u4((address)&lpc[1]);
+          int32_t  high = Bytes::get_Java_u4((address)&lpc[2]);
+          int32_t  skip;
+          key -= low;
+          skip = ((uint32_t) key > (uint32_t)(high - low))
+                      ? Bytes::get_Java_u4((address)&lpc[0])
+                      : Bytes::get_Java_u4((address)&lpc[key + 3]);
+          // Does this really need a full backedge check (osr?)
+          DO_BACKEDGE_CHECKS(skip);
+          UPDATE_PC_AND_TOS(skip, -1);
+          CONTINUE;
+      }
+
+      /* Goto pc whose table entry matches specified key */
+
+      CASE(_lookupswitch): {
+          jint* lpc  = (jint*)VMalignWordUp(pc+1);
+          int32_t  key  = STACK_INT(-1);
+          int32_t  skip = Bytes::get_Java_u4((address) lpc); /* default amount */
+          int32_t  npairs = Bytes::get_Java_u4((address) &lpc[1]);
+          while (--npairs >= 0) {
+              lpc += 2;
+              if (key == (int32_t)Bytes::get_Java_u4((address)lpc)) {
+                  skip = Bytes::get_Java_u4((address)&lpc[1]);
+                  break;
+              }
+          }
+          DO_BACKEDGE_CHECKS(skip);
+          UPDATE_PC_AND_TOS(skip, -1);
+          CONTINUE;
+      }
+
+      CASE(_fcmpl):
+      {
+          SET_STACK_INT(VMfloatCompare(STACK_FLOAT(-2),
+                                        STACK_FLOAT(-1),
+                                        -1),
+                        -2);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
+      }
+      CASE(_fcmpg):
+      {
+          SET_STACK_INT(VMfloatCompare(STACK_FLOAT(-2),
+                                        STACK_FLOAT(-1),
+                                        1),
+                        -2);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);
+      }
+
+      CASE(_dcmpl):
+      {
+          int r = VMdoubleCompare(STACK_DOUBLE(-3),
+                                  STACK_DOUBLE(-1),
+                                  -1);
+          MORE_STACK(-4); // Pop
+          SET_STACK_INT(r, 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+      }
+
+      CASE(_dcmpg):
+      {
+          int r = VMdoubleCompare(STACK_DOUBLE(-3),
+                                  STACK_DOUBLE(-1),
+                                  1);
+          MORE_STACK(-4); // Pop
+          SET_STACK_INT(r, 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+      }
+
+      CASE(_lcmp):
+      {
+          int r = VMlongCompare(STACK_LONG(-3), STACK_LONG(-1));
+          MORE_STACK(-4);
+          SET_STACK_INT(r, 0);
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);
+      }
+
+      /* Array access byte-codes */
+
+      /* Every array access byte-code starts out like this */
+//        arrayOopDesc* arrObj = (arrayOopDesc*)STACK_OBJECT(arrayOff);
+#define ARRAY_INTRO(arrayOff)                                                  \
+      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \
+      jint     index  = STACK_INT(arrayOff + 1);                               \
+      char message[jintAsStringSize];                                          \
+      CHECK_NULL(arrObj);                                                      \
+      if ((uint32_t)index >= (uint32_t)arrObj->length()) {                     \
+		goto finish;							\
+      }
+
+      /* 32-bit loads. These handle conversion from < 32-bit types */
+#define ARRAY_LOADTO32(T, T2, format, stackRes, extra)                                \
+      {                                                                               \
+          ARRAY_INTRO(-2);                                                            \
+          extra;                                                                      \
+          SET_ ## stackRes(*(T2 *)(((address) arrObj->base(T)) + index * sizeof(T2)), \
+                           -2);                                                       \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);                                      \
+      }
+
+      /* 64-bit loads */
+#define ARRAY_LOADTO64(T,T2, stackRes, extra)                                              \
+      {                                                                                    \
+          ARRAY_INTRO(-2);                                                                 \
+          SET_ ## stackRes(*(T2 *)(((address) arrObj->base(T)) + index * sizeof(T2)), -1); \
+          extra;                                                                           \
+          UPDATE_PC_AND_CONTINUE(1);                                            \
+      }
+
+      CASE(_iaload):
+          ARRAY_LOADTO32(T_INT, jint,   "%d",   STACK_INT, 0);
+      CASE(_faload):
+          ARRAY_LOADTO32(T_FLOAT, jfloat, "%f",   STACK_FLOAT, 0);
+      CASE(_aaload):
+          ARRAY_LOADTO32(T_OBJECT, oop,   INTPTR_FORMAT, STACK_OBJECT, 0);
+      CASE(_baload):
+          ARRAY_LOADTO32(T_BYTE, jbyte,  "%d",   STACK_INT, 0);
+      CASE(_caload):
+          ARRAY_LOADTO32(T_CHAR,  jchar, "%d",   STACK_INT, 0);
+      CASE(_saload):
+          ARRAY_LOADTO32(T_SHORT, jshort, "%d",   STACK_INT, 0);
+      CASE(_laload):
+          ARRAY_LOADTO64(T_LONG, jlong, STACK_LONG, 0);
+      CASE(_daload):
+          ARRAY_LOADTO64(T_DOUBLE, jdouble, STACK_DOUBLE, 0);
+
+      /* 32-bit stores. These handle conversion to < 32-bit types */
+#define ARRAY_STOREFROM32(T, T2, format, stackSrc, extra)                            \
+      {                                                                              \
+          ARRAY_INTRO(-3);                                                           \
+          extra;                                                                     \
+          *(T2 *)(((address) arrObj->base(T)) + index * sizeof(T2)) = stackSrc( -1); \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -3);                                     \
+      }
+
+      /* 64-bit stores */
+#define ARRAY_STOREFROM64(T, T2, stackSrc, extra)                                    \
+      {                                                                              \
+          ARRAY_INTRO(-4);                                                           \
+          extra;                                                                     \
+          *(T2 *)(((address) arrObj->base(T)) + index * sizeof(T2)) = stackSrc( -1); \
+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, -4);                                     \
+      }
+
+      CASE(_iastore):
+          ARRAY_STOREFROM32(T_INT, jint,   "%d",   STACK_INT, 0);
+      CASE(_fastore):
+          ARRAY_STOREFROM32(T_FLOAT, jfloat, "%f",   STACK_FLOAT, 0);
+      CASE(_bastore):
+          ARRAY_STOREFROM32(T_BYTE, jbyte,  "%d",   STACK_INT, 0);
+      CASE(_castore):
+          ARRAY_STOREFROM32(T_CHAR, jchar,  "%d",   STACK_INT, 0);
+      CASE(_sastore):
+          ARRAY_STOREFROM32(T_SHORT, jshort, "%d",   STACK_INT, 0);
+      CASE(_lastore):
+          ARRAY_STOREFROM64(T_LONG, jlong, STACK_LONG, 0);
+      CASE(_dastore):
+          ARRAY_STOREFROM64(T_DOUBLE, jdouble, STACK_DOUBLE, 0);
+
+      CASE(_arraylength):
+      {
+          arrayOop ary = (arrayOop) STACK_OBJECT(-1);
+          CHECK_NULL(ary);
+          SET_STACK_INT(ary->length(), -1);
+          UPDATE_PC_AND_CONTINUE(1);
+      }
+
+      /* monitorenter and monitorexit for locking/unlocking an object */
+
+      /* All of the non-quick opcodes. */
+
+      /* -Set clobbersCpIndex true if the quickened opcode clobbers the
+       *  constant pool index in the instruction.
+       */
+      CASE(_getfield):
+        {
+          u2 index;
+          ConstantPoolCacheEntry* cache;
+          index = Bytes::get_native_u2(pc+1);
+
+          // QQQ Need to make this as inlined as possible. Probably need to
+          // split all the bytecode cases out so c++ compiler has a chance
+          // for constant prop to fold everything possible away.
+
+          cache = cp->entry_at(index);
+          if (!cache->is_resolved(Bytecodes::_getfield)) {
+		FINISH();
+	  }
+
+          oop obj;
+          obj = (oop) STACK_OBJECT(-1);
+          CHECK_NULL(obj);
+
+          //
+          // Now store the result on the stack
+          //
+          TosState tos_type = cache->flag_state();
+          int field_offset = cache->f2();
+          if (cache->is_volatile()) {
+            if (tos_type == atos) {
+              SET_STACK_OBJECT(obj->obj_field_acquire(field_offset), -1);
+            } else if (tos_type == itos) {
+              SET_STACK_INT(obj->int_field_acquire(field_offset), -1);
+            } else if (tos_type == ltos) {
+              SET_STACK_LONG(obj->long_field_acquire(field_offset), 0);
+              MORE_STACK(1);
+            } else if (tos_type == btos) {
+              SET_STACK_INT(obj->byte_field_acquire(field_offset), -1);
+            } else if (tos_type == ctos) {
+              SET_STACK_INT(obj->char_field_acquire(field_offset), -1);
+            } else if (tos_type == stos) {
+              SET_STACK_INT(obj->short_field_acquire(field_offset), -1);
+            } else if (tos_type == ftos) {
+              SET_STACK_FLOAT(obj->float_field_acquire(field_offset), -1);
+            } else {
+              SET_STACK_DOUBLE(obj->double_field_acquire(field_offset), 0);
+              MORE_STACK(1);
+            }
+          } else {
+            if (tos_type == atos) {
+              SET_STACK_OBJECT(obj->obj_field(field_offset), -1);
+            } else if (tos_type == itos) {
+              SET_STACK_INT(obj->int_field(field_offset), -1);
+            } else if (tos_type == ltos) {
+              SET_STACK_LONG(obj->long_field(field_offset), 0);
+              MORE_STACK(1);
+            } else if (tos_type == btos) {
+              SET_STACK_INT(obj->byte_field(field_offset), -1);
+            } else if (tos_type == ctos) {
+              SET_STACK_INT(obj->char_field(field_offset), -1);
+            } else if (tos_type == stos) {
+              SET_STACK_INT(obj->short_field(field_offset), -1);
+            } else if (tos_type == ftos) {
+              SET_STACK_FLOAT(obj->float_field(field_offset), -1);
+            } else {
+              SET_STACK_DOUBLE(obj->double_field(field_offset), 0);
+              MORE_STACK(1);
+            }
+          }
+
+          UPDATE_PC_AND_CONTINUE(3);
+         }
+
+      CASE(_getstatic):
+        {
+          u2 index;
+          ConstantPoolCacheEntry* cache;
+          index = Bytes::get_native_u2(pc+1);
+
+          // QQQ Need to make this as inlined as possible. Probably need to
+          // split all the bytecode cases out so c++ compiler has a chance
+          // for constant prop to fold everything possible away.
+
+          cache = cp->entry_at(index);
+          if (!cache->is_resolved(Bytecodes::_getstatic)) {
+		FINISH();
+	  }
+
+          oop obj;
+	  obj = (oop) cache->f1();
+	  MORE_STACK(1);  // Assume single slot push
+
+          //
+          // Now store the result on the stack
+          //
+          TosState tos_type = cache->flag_state();
+          int field_offset = cache->f2();
+          if (cache->is_volatile()) {
+            if (tos_type == atos) {
+              SET_STACK_OBJECT(obj->obj_field_acquire(field_offset), -1);
+            } else if (tos_type == itos) {
+              SET_STACK_INT(obj->int_field_acquire(field_offset), -1);
+            } else if (tos_type == ltos) {
+              SET_STACK_LONG(obj->long_field_acquire(field_offset), 0);
+              MORE_STACK(1);
+            } else if (tos_type == btos) {
+              SET_STACK_INT(obj->byte_field_acquire(field_offset), -1);
+            } else if (tos_type == ctos) {
+              SET_STACK_INT(obj->char_field_acquire(field_offset), -1);
+            } else if (tos_type == stos) {
+              SET_STACK_INT(obj->short_field_acquire(field_offset), -1);
+            } else if (tos_type == ftos) {
+              SET_STACK_FLOAT(obj->float_field_acquire(field_offset), -1);
+            } else {
+              SET_STACK_DOUBLE(obj->double_field_acquire(field_offset), 0);
+              MORE_STACK(1);
+            }
+          } else {
+            if (tos_type == atos) {
+              SET_STACK_OBJECT(obj->obj_field(field_offset), -1);
+            } else if (tos_type == itos) {
+              SET_STACK_INT(obj->int_field(field_offset), -1);
+            } else if (tos_type == ltos) {
+              SET_STACK_LONG(obj->long_field(field_offset), 0);
+              MORE_STACK(1);
+            } else if (tos_type == btos) {
+              SET_STACK_INT(obj->byte_field(field_offset), -1);
+            } else if (tos_type == ctos) {
+              SET_STACK_INT(obj->char_field(field_offset), -1);
+            } else if (tos_type == stos) {
+              SET_STACK_INT(obj->short_field(field_offset), -1);
+            } else if (tos_type == ftos) {
+              SET_STACK_FLOAT(obj->float_field(field_offset), -1);
+            } else {
+              SET_STACK_DOUBLE(obj->double_field(field_offset), 0);
+              MORE_STACK(1);
+            }
+          }
+
+          UPDATE_PC_AND_CONTINUE(3);
+         }
+
+      CASE(_ldc):
+        {
+          u2 index;
+          index = pc[1];
+
+          constantPoolOop constants = METHOD->constants();
+          switch (constants->tag_at(index).value()) {
+          case JVM_CONSTANT_Integer:
+            SET_STACK_INT(constants->int_at(index), 0);
+            break;
+
+          case JVM_CONSTANT_Float:
+            SET_STACK_FLOAT(constants->float_at(index), 0);
+            break;
+
+          case JVM_CONSTANT_String:
+            SET_STACK_OBJECT(constants->resolved_string_at(index), 0);
+            break;
+
+          case JVM_CONSTANT_Class:
+            SET_STACK_OBJECT(constants->resolved_klass_at(index)->klass_part()->java_mirror(), 0);
+            break;
+
+	  default:
+		FINISH();
+
+          }
+          UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);
+        }
+
+      CASE(_ldc_w):
+        {
+          u2 index;
+          index = Bytes::get_Java_u2(pc+1);
+
+          constantPoolOop constants = METHOD->constants();
+          switch (constants->tag_at(index).value()) {
+          case JVM_CONSTANT_Integer:
+            SET_STACK_INT(constants->int_at(index), 0);
+            break;
+
+          case JVM_CONSTANT_Float:
+            SET_STACK_FLOAT(constants->float_at(index), 0);
+            break;
+
+          case JVM_CONSTANT_String:
+            SET_STACK_OBJECT(constants->resolved_string_at(index), 0);
+            break;
+
+          case JVM_CONSTANT_Class:
+            SET_STACK_OBJECT(constants->resolved_klass_at(index)->klass_part()->java_mirror(), 0);
+            break;
+
+	  default:
+		FINISH();
+
+          }
+          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1);
+        }
+
+      CASE(_ldc2_w):
+        {
+          u2 index = Bytes::get_Java_u2(pc+1);
+
+          constantPoolOop constants = METHOD->constants();
+          switch (constants->tag_at(index).value()) {
+
+          case JVM_CONSTANT_Long:
+             SET_STACK_LONG(constants->long_at(index), 1);
+            break;
+
+          case JVM_CONSTANT_Double:
+             SET_STACK_DOUBLE(constants->double_at(index), 1);
+            break;
+          default:  ShouldNotReachHere();
+          }
+          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 2);
+        }
+
+      /* goto and jsr. They are exactly the same except jsr pushes
+       * the address of the next instruction first.
+       */
+
+      CASE(_jsr): {
+          /* push bytecode index on stack */
+          SET_STACK_ADDR(((address)pc - (intptr_t)(istate->method()->code_base()) + 3), 0);
+          MORE_STACK(1);
+          /* FALL THROUGH */
+      }
+
+      CASE(_goto):
+      {
+          int16_t offset = (int16_t)Bytes::get_Java_u2(pc + 1);
+          DO_BACKEDGE_CHECKS(offset);
+          UPDATE_PC(offset);
+          CONTINUE;
+      }
+
+      /* return from a jsr or jsr_w */
+
+      CASE(_ret): {
+          pc = istate->method()->code_base() + (intptr_t)(LOCALS_ADDR(pc[1]));
+          UPDATE_PC_AND_CONTINUE(0);
+      }
+
+      }
+
+  }
+
+finish:
+	FINISH();
+}
+
+#endif // CC_INTERP
