Author: Chris Phillips <ChrisPhi@lgonqn.org>
Description :
 Get zero/shark to compile for b147.
 http://lgonqn.org/temp/ChrisPhi/webrev-frame_zero.cpp-describe_pd_missing/
 http://lgonqn.org/temp/ChrisPhi/webrev-sharedRuntime_zero.cpp-needs-rework-after-indy-reorg/
 http://lgonqn.org/temp/ChrisPhi/webrev-sharkContext.hpp-typo-in-assert/
 http://lgonqn.org/temp/ChrisPhi/webrev-methodHandles_zero.hpp-missing/
--- /dev/null
+++ openjdk/hotspot/src/cpu/zero/vm/methodHandles_zero.hpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2011 Red Hat, Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+
+// Adapters
+// just copied from x64 for now.
+enum /* platform_dependent_constants */ {
+  adapter_code_size = NOT_LP64(30000 DEBUG_ONLY(+ 10000)) LP64_ONLY(80000 DEBUG_ONLY(+ 120000))
+};
+
+#define TARGET_ARCH_NYI_6939861 
+// ..#ifdef TARGET_ARCH_NYI_6939861
+// ..  // Here are some backward compatible declarations until the 6939861 ports are updated.
+// ..  #define _adapter_flyby    (_EK_LIMIT + 10)
+// ..  #define _adapter_ricochet (_EK_LIMIT + 11)
+// ..  #define _adapter_opt_spread_1    _adapter_opt_spread_1_ref
+// ..  #define _adapter_opt_spread_more _adapter_opt_spread_ref
+// ..  enum {
+// ..    _INSERT_NO_MASK   = -1,
+// ..    _INSERT_REF_MASK  = 0,
+// ..    _INSERT_INT_MASK  = 1,
+// ..    _INSERT_LONG_MASK = 3
+// ..  };
+// ..  static void get_ek_bound_mh_info(EntryKind ek, BasicType& arg_type, int& arg_mask, int& arg_slots) {
+// ..    arg_type = ek_bound_mh_arg_type(ek);
+// ..    arg_mask = 0;
+// ..    arg_slots = type2size[arg_type];;
+// ..  }
+// ..  static void get_ek_adapter_opt_swap_rot_info(EntryKind ek, int& swap_bytes, int& rotate) {
+// ..    int swap_slots = ek_adapter_opt_swap_slots(ek);
+// ..    rotate = ek_adapter_opt_swap_mode(ek);
+// ..    swap_bytes = swap_slots * Interpreter::stackElementSize;
+// ..  }
+// ..  static int get_ek_adapter_opt_spread_info(EntryKind ek) {
+// ..    return ek_adapter_opt_spread_count(ek);
+// ..  }
+// ..
+// ..  static void insert_arg_slots(MacroAssembler* _masm,
+// ..                               RegisterOrConstant arg_slots,
+// ..                               int arg_mask,
+// ..                               Register argslot_reg,
+// ..                               Register temp_reg, Register temp2_reg, Register temp3_reg = noreg);
+// ..
+// ..  static void remove_arg_slots(MacroAssembler* _masm,
+// ..                               RegisterOrConstant arg_slots,
+// ..                               Register argslot_reg,
+// ..                               Register temp_reg, Register temp2_reg, Register temp3_reg = noreg);
+// ..
+// ..  static void trace_method_handle(MacroAssembler* _masm, const char* adaptername) PRODUCT_RETURN;
+// ..#endif //TARGET_ARCH_NYI_6939861
+
--- openjdk/hotspot/src/cpu/zero/vm/sharedRuntime_zero.cpp.orig
+++ openjdk/hotspot/src/cpu/zero/vm/sharedRuntime_zero.cpp
@@ -46,6 +46,7 @@
 #include "shark/sharkCompiler.hpp"
 #endif
 
+#ifdef notdef
 DeoptimizationBlob *SharedRuntime::_deopt_blob;
 SafepointBlob      *SharedRuntime::_polling_page_safepoint_handler_blob;
 SafepointBlob      *SharedRuntime::_polling_page_return_handler_blob;
@@ -54,6 +55,7 @@
 RuntimeStub        *SharedRuntime::_resolve_opt_virtual_call_blob;
 RuntimeStub        *SharedRuntime::_resolve_virtual_call_blob;
 RuntimeStub        *SharedRuntime::_resolve_static_call_blob;
+#endif
 
 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
                                            VMRegPair *regs,
@@ -114,6 +116,23 @@
   return SafepointBlob::create(&buffer, NULL, 0);
 }
 
+static DeoptimizationBlob* generate_empty_deopt_blob() {
+  CodeBuffer buffer("handler_blob", 0, 0);
+  return DeoptimizationBlob::create(&buffer, NULL, 0, 0, 0, 0);
+}
+
+void SharedRuntime::generate_deopt_blob() {
+  _deopt_blob = generate_empty_deopt_blob();
+}
+
+SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, bool cause_return) {
+  return generate_empty_safepoint_blob();
+}
+
+RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
+  return generate_empty_runtime_stub("resolve_blob");
+}
+#ifdef notdef
 void SharedRuntime::generate_stubs() {
   _wrong_method_blob =
     generate_empty_runtime_stub("wrong_method_stub");
@@ -131,6 +150,7 @@
   _polling_page_return_handler_blob =
     generate_empty_safepoint_blob();
 }
+#endif
 
 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
                                          VMRegPair *regs,
--- openjdk/hotspot/src/cpu/zero/vm/frame_zero.cpp.orig
+++ openjdk/hotspot/src/cpu/zero/vm/frame_zero.cpp
@@ -417,3 +417,11 @@
     return;
   }
 }
+
+#ifdef ASSERT
+
+void frame::describe_pd(FrameValues& values, int frame_no) {
+
+}
+
+#endif
--- openjdk/hotspot/src/share/vm/shark/sharkCompiler.cpp.orig
+++ openjdk/hotspot/src/share/vm/shark/sharkCompiler.cpp
@@ -319,7 +319,8 @@
   // finish with the exception of the VM thread, so we can consider
   // ourself the owner of the execution engine lock even though we
   // can't actually acquire it at this time.
-  assert(Thread::current()->is_VM_thread(), "must be called by VM thread");
+  assert(JavaThread::current()->thread_state() == _thread_in_vm, "must run in vm mode");
+//assert(Thread::current()->is_VM_thread(), "must be called by VM thread");
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
 
   SharkEntry *entry = (SharkEntry *) code;
--- openjdk/hotspot/src/share/vm/shark/sharkContext.hpp.orig
+++ openjdk/hotspot/src/share/vm/shark/sharkContext.hpp
@@ -171,7 +171,7 @@
                              BasicType                type) const {
     assert(type >= 0 && type < T_CONFLICT, "unhandled type");
     const llvm::Type* result = table[type];
-    assert(type != NULL, "unhandled type");
+    assert(result != NULL, "unhandled type");
     return result;
   }
 
