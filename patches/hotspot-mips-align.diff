--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.hpp
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.hpp
@@ -56,7 +56,16 @@
     jlong   l;
     jdouble d;
     uint32_t      v[2];
-};
+}
+#ifndef _LP64
+  /* Hotspot only aligns the union to the uintptr_t type, that is 32 bit
+     on a 32-bit CPU. Accesses to double values should be 64-bit aligned
+     on at least MIPS and SPARC. Declare it to GCC for all 32-bit CPUs,
+     as it might also help GCC to select the best instruction on other
+     CPUs. */
+  __attribute__ ((packed, aligned (4)))
+#endif
+;
 
 
 typedef class BytecodeInterpreter* interpreterState;
@@ -169,7 +178,16 @@
     jlong   l;
     jdouble d;
     uint32_t      v[2];
-};
+}
+#ifndef _LP64
+  /* Hotspot only aligns the union to the uintptr_t type, that is 32 bit
+     on a 32-bit CPU. Accesses to double values should be 64-bit aligned
+     on at least MIPS and SPARC. Declare it to GCC for all 32-bit CPUs,
+     as it might also help GCC to select the best instruction on other
+     CPUs. */
+  __attribute__ ((packed, aligned (4)))
+#endif
+;
 
 /*
  * Generic 32-bit wide "Java slot" definition. This type occurs
--- openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_zero.cpp
+++ openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_zero.cpp
@@ -322,7 +322,7 @@
   ThreadStateTransition::transition_from_java(thread, _thread_in_native);
 
   // Make the call
-  intptr_t result[4 - LogBytesPerWord];
+  intptr_t result[4 - LogBytesPerWord] __attribute__((__aligned__(__alignof__(double))));
   ffi_call(handler->cif(), (void (*)()) function, result, arguments);
 
   // Change the thread state back to _thread_in_Java.
